name: 'Cerberus Council Verdict'
description: 'Aggregate Cerberus review verdicts into a council decision'
author: 'misty-step'

inputs:
  github-token:
    description: 'GitHub token for PR comments'
    required: true
  fail-on-verdict:
    description: 'Exit with failure if council verdict is FAIL'
    default: 'true'

outputs:
  verdict:
    description: 'Council verdict (PASS, WARN, FAIL)'
    value: ${{ steps.aggregate.outputs.verdict }}

runs:
  using: 'composite'
  steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Download verdict artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./verdicts/
        pattern: cerberus-verdict-*
        merge-multiple: true

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Check for override
      id: override
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        REPO: ${{ github.repository }}
      run: |
        # REST issue comments use .user.login; GraphQL comments use .author.login.
        if ! OVERRIDE=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" --jq '[.[] | select(.body | startswith("/council override")) | {actor: .user.login, body: .body}] | last' 2>&1); then
          echo "::warning::Failed to fetch override comments: $OVERRIDE"
          OVERRIDE=""
        fi
        {
          echo "override<<CERBERUS_OVERRIDE_EOF"
          echo "$OVERRIDE"
          echo "CERBERUS_OVERRIDE_EOF"
        } >> "$GITHUB_OUTPUT"

    - name: Aggregate verdicts
      id: aggregate
      shell: bash
      env:
        CERBERUS_ROOT: ${{ github.action_path }}/..
        GH_OVERRIDE_COMMENT: ${{ steps.override.outputs.override }}
        GH_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        GH_PR_AUTHOR: ${{ github.event.pull_request.user.login }}
        GH_OVERRIDE_POLICY: pr_author
      run: |
        python3 "$CERBERUS_ROOT/scripts/aggregate-verdict.py" ./verdicts/
        echo "verdict=$(jq -r .verdict /tmp/council-verdict.json)" >> "$GITHUB_OUTPUT"

    - name: Post council verdict
      if: always() && steps.aggregate.outcome == 'success'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        REPO: ${{ github.repository }}
      run: |
        VERDICT=$(jq -r .verdict /tmp/council-verdict.json)
        SUMMARY=$(jq -r .summary /tmp/council-verdict.json)
        if [ "$VERDICT" = "null" ] || [ -z "$VERDICT" ]; then
          echo "::error::Council verdict JSON is malformed"
          exit 1
        fi
        EMOJI="‚úÖ"
        if [ "$VERDICT" = "FAIL" ]; then EMOJI="‚ùå"; fi
        if [ "$VERDICT" = "WARN" ]; then EMOJI="‚ö†Ô∏è"; fi
        if [ "$VERDICT" = "SKIP" ]; then EMOJI="‚è≠Ô∏è"; fi
        MARKER="<!-- cerberus:council -->"

        # Detect SKIP reasons across all reviewer verdicts using structured fields
        SKIP_BANNER=""
        for f in ./verdicts/*.json; do
          [ -f "$f" ] || continue
          v_verdict=$(jq -r '.verdict // empty' "$f")
          [ "$v_verdict" = "SKIP" ] || continue
          v_category=$(jq -r '.findings[0].category // empty' "$f")
          v_title=$(jq -r '.findings[0].title // empty' "$f")
          if [ "$v_category" = "api_error" ]; then
            if printf '%s' "$v_title" | grep -qiE "CREDITS_DEPLETED|QUOTA_EXCEEDED"; then
              SKIP_BANNER="> **‚õî API credits depleted for one or more reviewers.** Some reviews were skipped because the API provider has no remaining credits. Top up credits or configure a fallback provider."
            elif printf '%s' "$v_title" | grep -qiE "KEY_INVALID"; then
              SKIP_BANNER="> **üîë API key error for one or more reviewers.** Some reviews were skipped due to authentication failures. Check that the API key is valid."
            else
              SKIP_BANNER="> **‚ö†Ô∏è API error for one or more reviewers.** Some reviews were skipped due to API errors."
            fi
            break
          elif [ "$v_category" = "timeout" ]; then
            SKIP_BANNER="> **‚è±Ô∏è One or more reviewers timed out.** Some reviews were skipped because they exceeded the configured runtime limit."
            break
          fi
        done

        {
          printf '%s\n' "$MARKER"
          printf '%s\n' "## ${EMOJI} Council Verdict: ${VERDICT}"
          printf '\n'
          if [ -n "$SKIP_BANNER" ]; then
            printf '%s\n' "$SKIP_BANNER"
            printf '\n'
          fi
          printf '%s\n' "$SUMMARY"
          printf '\n'
          printf '%s\n' "---"
          printf '%s\n' "*Cerberus Council*"
        } > /tmp/council-comment.md

        print_permissions_help() {
          {
            echo "::error::Unable to post council PR comment: token lacks pull request write permission."
            echo "Add this to your workflow:"
            echo "permissions:"
            echo "  contents: read"
            echo "  pull-requests: write"
          } >&2
        }

        EXISTING=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" --jq '.[] | select(.body | contains("cerberus:council")) | .id' 2>/tmp/cerberus-council.err | head -1) || true
        if [ -n "$EXISTING" ]; then
          # Pass body via gh's @file reader to avoid shell interpolation of comment content.
          if ! gh api "repos/${REPO}/issues/comments/${EXISTING}" -X PATCH -F body=@/tmp/council-comment.md >/tmp/cerberus-council.out 2>/tmp/cerberus-council.err; then
            cat /tmp/cerberus-council.err >&2
            if grep -qiE "403|resource not accessible by integration|insufficient" /tmp/cerberus-council.err; then
              print_permissions_help
            fi
            exit 1
          fi
        else
          if ! gh pr comment "$PR_NUMBER" --body-file /tmp/council-comment.md >/tmp/cerberus-council.out 2>/tmp/cerberus-council.err; then
            cat /tmp/cerberus-council.err >&2
            if grep -qiE "403|resource not accessible by integration|insufficient" /tmp/cerberus-council.err; then
              print_permissions_help
            fi
            exit 1
          fi
        fi

    - name: Check verdict
      if: always() && steps.aggregate.outcome == 'success' && inputs.fail-on-verdict == 'true'
      shell: bash
      run: |
        VERDICT=$(jq -r .verdict /tmp/council-verdict.json)
        if [ "$VERDICT" = "FAIL" ]; then
          echo "::error::Council Verdict: FAIL"
          exit 1
        fi
        if [ "$VERDICT" = "SKIP" ]; then
          echo "::notice::Council Verdict: SKIP (all reviews skipped due to timeout/API errors)"
          exit 0
        fi
